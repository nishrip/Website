<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Landing Page with Sections</title>
<link rel="stylesheet" href="global.css">
<!-- Panolens / Three.js / Tween (für Panorama) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r110/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/panolens@0.12.0/build/panolens.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/Tween.min.js"></script>

<style>
#portfolio {
  color: #d33a57;
  text-decoration: none;
  text-shadow: 0 0 3px rgba(0, 0, 0, 0.47);
  font-weight: bold;
  outline: none;
}

/* Section card */
section {
  position: relative;
  margin: 50% auto;
  padding: 1rem 1rem;
  width: 90%;
  max-width: 900px;
  background: rgba(0, 0, 0, 0.84);
  border-radius: 20px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
  z-index: 1;
}

/* Mask container */
section .mask {
  position: relative;
  overflow: hidden;
  max-height: calc(100vh - 100px);
  margin: 0 auto;
}

/* Actual text/content */
section .content {
  max-width: 900px;
  margin: 0 auto;
  padding: 2rem 1rem;
  color: #ffffff;
  text-align: center;
}

.video-wrapper {
  width: 100%;
  height: 300px;
  border-radius: 12px;
  overflow: hidden;
}
.video-wrapper iframe {
  width: 100%;
  height: 100%;
  border: none;
}

/* Responsive */
@media (max-width: 480px) {
  section {
    padding: rem 1rem;
    width: 95%;
    border-radius: 16px;
  }
  section .content {
    padding: 1.5rem 1rem;
  }
}

/* --- Vergleichsslider Styles --- */
.container {
  position: relative;
  width: 100%;
  background: #000;
  overflow: hidden;
  touch-action: none;
  border-radius: 10px;
  aspect-ratio: 16/9;
}
.pane {
  position: absolute;
  top: 0; bottom: 0; width: 100%;
  background-size: cover;
  background-repeat: no-repeat;
  background-position: center center;
  cursor: grab;
  user-select: none;
  outline: none;
  -webkit-tap-highlight-color: transparent;
  transition: background-position 0.1s;
}
#left { z-index: 1; }
#right { z-index: 2; clip-path: inset(0 0 0 50%); }
#slider {
  position: absolute;
  top: 0; bottom: 0;
  left: 50%;
  width: 10px;
  margin-left: -5px;
  background: rgba(99, 168, 219, 0.53);
  border-left: 2px solid rgba(255, 255, 255, 0.2);
  border-right: 2px solid rgba(255, 255, 255, 0.2);
  cursor: ew-resize;
  z-index: 3;
  outline: none;
  -webkit-tap-highlight-color: transparent;
}
#slider:hover {
  background: rgba(255, 177, 0, 0.8);
}

/* Overlay close button */
.overlay-close {
  position: absolute;
  top: 20px; right: 20px;
  width: 40px; height: 40px;
  border: none; border-radius: 50%;
  background: rgba(255,255,255,0.7);
  font-size: 24px;
  cursor: pointer;
  z-index: 10;
}

/* Panorama overlay internal container should fill the panoOverlay area */
#panoViewFullInner {
  width: 100%;
  height: 100%;
  position: relative;
  background: #000;
}
#panoFadeOverlay {
  position: absolute;
  top:0; left:0; width:100%; height:100%;
  background:black; opacity:0; pointer-events:none; z-index:20;
  transition: opacity 0.3s ease;
}
</style>
</head>
<body>

<!-- Navigation -->
<nav>
  <div class="logo"><a href="index.html">PREISE</a></div>
  <div class="nav-links" id="navLinks">
    <a id="portfolio" href="#">PORTFOLIO</a>
    <a href="#">PREISE</a>
    <a href="#">CLIENTS</a>
    <a href="#">KONTAKT</a>
  </div>
  <div class="hamburger" id="hamburger">
    <div></div><div></div><div></div>
  </div>
</nav>

<!-- Background animation -->
<canvas id="sequence"></canvas>

<!-- === Sections === -->
<section id="section1">
  <div class="mask">
    <div class="content">
      <h2>Einzelfotos</h2>
      <div class="photo-gallery" style="position: relative;">
        <button id="prevPhoto" style="position:absolute;left:10px;top:50%;">&#10094;</button>
        <img id="galleryImage" src="images/photo1.jpg" alt="Gallery" style="width:100%;border-radius:10px;">
        <button id="nextPhoto" style="position:absolute;right:10px;top:50%;">&#10095;</button>
      </div>
    </div>
  </div>
</section>

<section id="section2">
  <div class="mask">
    <div class="content">
      <h2>Vergleichsslider</h2>
      <img id="sliderPreview" src="Vergleich.jpg" style="width:100%;border-radius:10px;cursor:pointer;">
    </div>
  </div>
</section>

<section id="section3">
  <div class="mask">
    <div class="content">
      <h2>360° Ansicht</h2>
      <img id="panoPreview" src="pano/pano1.jpg" style="width:100%;border-radius:10px;cursor:pointer;">
    </div>
  </div>
</section>

<section id="section4">
  <div class="mask">
    <div class="content">
      <h2>Video</h2>
      <div class="video-wrapper">
        <iframe loading="lazy" title="YouTube video player"
                src="https://www.youtube.com/embed/bLCyMWfFf4M"
                style="border:0;"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen"
                allowfullscreen>
        </iframe>
      </div>
    </div>
  </div>
</section>

<!-- Slider Overlay -->
<div id="sliderOverlay" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000;z-index:100;">
  <button class="overlay-close" id="closeSliderOverlay">×</button>
  <div class="container" style="width:90%;max-width:1920px;margin:0 auto;position:relative;top:50%;transform:translateY(-50%);aspect-ratio:16/9;">
    <div id="left" class="pane" style="background-image:url('V1.png');"></div>
    <div id="right" class="pane" style="background-image:url('V2.png');"></div>
    <div id="slider"></div>
  </div>
</div>

<!-- Panorama Overlay (full-screen) -->
<div id="panoOverlay" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000;z-index:150;">
  <button class="overlay-close" id="closePanoOverlay">×</button>
  <div id="panoViewFull" style="width:100%;height:100%;margin:0;position:relative;top:0;left:0;background:#111;border-radius:0;">
    <!-- inner container for Panolens viewer -->
    <div id="panoViewFullInner">
      <div id="panoFadeOverlay"></div>
      <div id="panoContainer" style="width:100%;height:100%;position:relative;z-index:1;"></div>
    </div>
  </div>
</div>

<script>
// ===== Canvas animation =====
const canvas = document.getElementById("sequence");
const ctx = canvas.getContext("2d");
const frameCount = 122;
const images = [];
let currentFrame = 0;
let targetFrame = 0;
const getFramePath = i => `frames1/${(i + 120).toString().padStart(4, '0')}.jpg`;
function drawImageCover(img){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  const scale = Math.max(canvas.width/img.width, canvas.height/img.height);
  const x = (canvas.width/2)-(img.width/2)*scale;
  const y = (canvas.height/2)-(img.height/2)*scale;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img, x, y, img.width*scale, img.height*scale);
}
function loadFrame(i){
  if(i<0||i>=frameCount) return;
  if(!images[i]){
    const img = new Image();
    img.src = getFramePath(i);
    img.onload = ()=>{if(i===currentFrame) drawImageCover(img);};
    images[i]=img;
  }
  return images[i];
}
function preloadNearbyFrames(center, range=20){
  for(let offset=-range; offset<=range; offset++){
    loadFrame(center+offset);
  }
}
loadFrame(0);
preloadNearbyFrames(0,20);
window.addEventListener('scroll', ()=>{
  const scrollTop = window.scrollY;
  const scrollHeight = document.body.scrollHeight - window.innerHeight;
  const scrollFraction = scrollTop / scrollHeight;
  targetFrame = Math.min(frameCount-1, Math.floor(scrollFraction*frameCount));
});
function animateFrames(){
  if(currentFrame!==targetFrame){
    const dir = targetFrame>currentFrame ? 1:-1;
    currentFrame += dir;
    const img = loadFrame(currentFrame);
    if(img?.complete) drawImageCover(img);
    preloadNearbyFrames(currentFrame,20);
  }
  requestAnimationFrame(animateFrames);
}
animateFrames();
window.addEventListener("resize", ()=>{ if(images[currentFrame]?.complete) drawImageCover(images[currentFrame]); });

// ===== Hamburger menu =====
document.getElementById("hamburger").addEventListener("click", ()=>document.getElementById("navLinks").classList.toggle("show"));

// ===== Galerie Navigation =====
const photos = ["images/photo1.jpg","images/photo2.jpg","images/photo3.jpg"];
let photoIndex = 0;
const galleryImage = document.getElementById("galleryImage");
document.getElementById("nextPhoto").addEventListener("click", ()=>{photoIndex = (photoIndex + 1) % photos.length;galleryImage.src = photos[photoIndex];});
document.getElementById("prevPhoto").addEventListener("click", ()=>{photoIndex = (photoIndex - 1 + photos.length) % photos.length;galleryImage.src = photos[photoIndex];});

// ===== Slider Overlay Logic =====
const sliderOverlay = document.getElementById('sliderOverlay');
const overlayContainer = sliderOverlay.querySelector('.container');
const sliderOverlayLeft = overlayContainer.querySelector('#left');
const sliderOverlayRight = overlayContainer.querySelector('#right');
const sliderHandle = overlayContainer.querySelector('#slider');

let isDraggingSlider=false, isDraggingView=false, dragStartX=0, dragStartY=0, dragLastX=0, dragLastY=0, scale=1, posX=0, posY=0;

function clamp(v,min,max){return Math.min(Math.max(v,min),max);}
function updateSliderOverlay(x){
  const rect = overlayContainer.getBoundingClientRect();
  const offsetX = clamp(x - rect.left, 0, rect.width);
  const percent = (offsetX / rect.width) * 100;
  sliderHandle.style.left = percent + '%';
  sliderOverlayRight.style.clipPath = `inset(0 0 0 ${percent}%)`;
}

sliderHandle.addEventListener('mousedown', e=>{isDraggingSlider=true;e.preventDefault();});
document.addEventListener('mouseup', ()=>isDraggingSlider=false);
document.addEventListener('mousemove', e=>{if(isDraggingSlider) updateSliderOverlay(e.clientX);});

// Touch support
sliderHandle.addEventListener('touchstart', e=>{isDraggingSlider=true;e.preventDefault();}, {passive:false});
sliderHandle.addEventListener('touchend', e=>{isDraggingSlider=false;e.preventDefault();}, {passive:false});
sliderHandle.addEventListener('touchmove', e=>{if(isDraggingSlider) updateSliderOverlay(e.touches[0].clientX);}, {passive:false});

overlayContainer.addEventListener('mousedown', e=>{
  if(isDraggingSlider) return;
  isDraggingView=true;
  dragStartX=e.clientX; dragStartY=e.clientY;
  dragLastX=posX; dragLastY=posY;
  overlayContainer.style.cursor='grabbing';
  e.preventDefault();
});
document.addEventListener('mouseup', ()=>{if(isDraggingView){isDraggingView=false;overlayContainer.style.cursor='default';}});
document.addEventListener('mousemove', e=>{if(isDraggingView){posX = dragLastX + (e.clientX - dragStartX); posY = dragLastY + (e.clientY - dragStartY); updateBackgroundPositionOverlay();}});

overlayContainer.addEventListener('touchstart', e=>{
  if(e.target===sliderHandle) return;
  isDraggingView=true;
  dragStartX=e.touches[0].clientX; dragStartY=e.touches[0].clientY;
  dragLastX=posX; dragLastY=posY;
}, {passive:false});
overlayContainer.addEventListener('touchmove', e=>{
  if(!isDraggingView) return;
  e.preventDefault();
  posX = dragLastX + (e.touches[0].clientX - dragStartX);
  posY = dragLastY + (e.touches[0].clientY - dragStartY);
  updateBackgroundPositionOverlay();
}, {passive:false});
overlayContainer.addEventListener('touchend', e=>{isDraggingView=false;}, {passive:false});

// ===== MOBILE-SPECIFIC MIN ZOOM FUNCTION =====
function getMinScale() {
  return window.innerWidth < 700 ? 3.2 : 1; // Mobile minimum = 3.2
}

// Zoom
overlayContainer.addEventListener('wheel', e=>{
  e.preventDefault();
  scale = clamp(scale - e.deltaY * 0.0015, getMinScale(), 5);
  updateBackgroundPositionOverlay();
}, { passive:false });

// Pinch zoom
let lastDistance = null;
overlayContainer.addEventListener('touchmove', e=>{
  if(e.touches.length===2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const distance = Math.hypot(dx, dy);
    if(lastDistance){
      const delta = (distance - lastDistance) * 0.01;
      scale = clamp(scale + delta, getMinScale(), 5);
      updateBackgroundPositionOverlay();
    }
    lastDistance = distance;
  } else {
    lastDistance = null;
  }
}, { passive:false });

// Update Background
function updateBackgroundPositionOverlay(){
  const rect = overlayContainer.getBoundingClientRect();
  const imgAspect = 1920/1080;
  const containerAspect = rect.width/rect.height;
  let bgWidth,bgHeight;

  if(containerAspect>imgAspect){
    bgHeight = rect.height*scale;
    bgWidth = bgHeight*imgAspect;
  }else{
    bgWidth = rect.width*scale;
    bgHeight = bgWidth/imgAspect;
  }

  const maxShiftX = (bgWidth - rect.width)/2;
  const maxShiftY = (bgHeight - rect.height)/2;
  posX = clamp(posX,-maxShiftX,maxShiftX);
  posY = clamp(posY,-maxShiftY,maxShiftY);

  const posXPercent = 50 - (posX/bgWidth*100);
  const posYPercent = 50 - (posY/bgHeight*100);

  sliderOverlayLeft.style.backgroundSize = `${bgWidth}px ${bgHeight}px`;
  sliderOverlayRight.style.backgroundSize = `${bgWidth}px ${bgHeight}px`;
  sliderOverlayLeft.style.backgroundPosition = `${posXPercent}% ${posYPercent}%`;
  sliderOverlayRight.style.backgroundPosition = `${posXPercent}% ${posYPercent}%`;
}

// Open/Close Slider Overlay
document.getElementById('sliderPreview').addEventListener('click', ()=>{
  ['V1.png','V2.png'].forEach(src => { const i = new Image(); i.src = src; });
  sliderOverlay.style.display='block';
  document.body.style.overflow='hidden';
  requestAnimationFrame(()=>{ setInitialZoom(); updateBackgroundPositionOverlay(); });
});
document.getElementById('closeSliderOverlay').addEventListener('click', ()=>{
  sliderOverlay.style.display='none';
  document.body.style.overflow='';
});

// Initial Zoom & Aspect Ratio
function setInitialZoom(){
  if(window.innerWidth < 700){
    overlayContainer.style.aspectRatio = "9/16";
    overlayContainer.style.width = "90%";
    scale = 3.2; // Mobile default zoom
  } else {
    overlayContainer.style.aspectRatio = "16/9";
    overlayContainer.style.width = "90%";
    scale = 1; // Mobile default zoom
  }
  posX = 0;
  posY = 0;
  updateBackgroundPositionOverlay();
}
window.addEventListener('resize', setInitialZoom);
setInitialZoom();

// ===== Panorama Overlay Integration (loads panoramas & hotspots from pano/ ) =====
const panoOverlay = document.getElementById('panoOverlay');
const panoContainer = document.getElementById('panoContainer');
const panoFade = document.getElementById('panoFadeOverlay');
let panoViewer = null;
let panoramas = [];
let panoInitialized = false;
let panoLoader = null;
let panoCamera = null;

// Panorama file list (expects files in pano/ folder)
const panoramaPaths = [
  'pano/pano1.jpg',
  'pano/pano2.jpg',
  'pano/pano3.jpg',
  'pano/pano4.jpg',
  'pano/pano5.jpg',
  'pano/pano6.jpg',
  'pano/pano7.jpg',
  'pano/add1.jpg',
  'pano/add2.jpg'
];

function createPanoramaViewer() {
  // create viewer inside panoContainer
  panoViewer = new PANOLENS.Viewer({
    container: panoContainer,
    controlBar: true,
    autoHideInfospot: false
  });
  panoCamera = panoViewer.getCamera();
  panoramas = new Array(panoramaPaths.length);

  panoLoader = new THREE.TextureLoader();
  let loadedCount = 0;

  function onTextureLoad(texture, index) {
    // create panorama from the already-loaded image src (keeps the loader caching)
    const pano = new PANOLENS.ImagePanorama(texture.image.src);
    panoramas[index] = pano;
    loadedCount++;

    if (loadedCount === panoramaPaths.length) {
      setupPanoramaHotspots();
      panoViewer.add(...panoramas);
      // start at panoramas[7] (like your original pano code)
      try { panoViewer.setPanorama(panoramas[7]); } catch (e) {}
      // small initial tween to set a view
      try { panoViewer.tweenControlCenter(new THREE.Vector3(10, 1, 1), 0); } catch (e) {}
    }
  }

  function preloadPanorama(index) {
    panoLoader.load(
      panoramaPaths[index],
      texture => onTextureLoad(texture, index),
      undefined,
      err => {
        console.error(`Failed to load ${panoramaPaths[index]}:`, err);
        // still mark as loaded to avoid blocking if missing
        panoramas[index] = new PANOLENS.ImagePanorama(panoramaPaths[index]);
        loadedCount++;
        if (loadedCount === panoramaPaths.length) {
          setupPanoramaHotspots();
          panoViewer.add(...panoramas);
          try { panoViewer.setPanorama(panoramas[7]); } catch (e) {}
        }
      }
    );
  }

  for (let i = 0; i < panoramaPaths.length; i++) {
    preloadPanorama(i);
  }

  panoInitialized = true;
}

// Attach hotspots similar to your pano code, using pano/ for images
function setupPanoramaHotspots() {
  // create infospots (hotspot images loaded from pano/ folder)
  const spotAddto1 = new PANOLENS.Infospot(250, 'pano/Hotspot18.png');
  spotAddto1.position.set(4000, -200, -650);
  const spotAddtoUp = new PANOLENS.Infospot(250, 'pano/UP7.png');
  spotAddtoUp.position.set(5000, 4000, 500);

  const spot1to2 = new PANOLENS.Infospot(250, 'pano/Hotspot.png');
  spot1to2.position.set(4000, -150, -1500);
  const spot1toAdd = new PANOLENS.Infospot(250, 'pano/Hotspot17.png');
  spot1toAdd.position.set(-3200, -200, 4000);
  const spot1toUP = new PANOLENS.Infospot(250, 'pano/UP.png');
  spot1toUP.position.set(2000, 4000, -800);

  const spot2to1 = new PANOLENS.Infospot(250, 'pano/Hotspot2.png');
  spot2to1.position.set(-4000, -200, -1800);
  const spot2to3 = new PANOLENS.Infospot(250, 'pano/Hotspot3.png');
  spot2to3.position.set(4000, -200, -565);
  const spot2toUP = new PANOLENS.Infospot(250, 'pano/UP1.png');
  spot2toUP.position.set(-1000, 4000, -300);

  const spot3to2 = new PANOLENS.Infospot(250, 'pano/Hotspot4.png');
  spot3to2.position.set(4000, -200, -20);
  const spot3to4 = new PANOLENS.Infospot(250, 'pano/Hotspot5.png');
  spot3to4.position.set(-3000, -1800, 3000);
  const spot3toUP = new PANOLENS.Infospot(250, 'pano/UP2.png');
  spot3toUP.position.set(5000, 4000, 200);

  const spot4to3 = new PANOLENS.Infospot(250, 'pano/Hotspot6.png');
  spot4to3.position.set(3000, 1200, -3000);
  const spot4to5 = new PANOLENS.Infospot(250, 'pano/Hotspot7.png');
  spot4to5.position.set(350, -200, -5000);
  const spot4toUP = new PANOLENS.Infospot(250, 'pano/UP3.png');
  spot4toUP.position.set(4500, 5000, -2000);

  const spot5to4 = new PANOLENS.Infospot(250, 'pano/Hotspot8.png');
  spot5to4.position.set(-400, 150, 5000);
  const spot5toAdd2 = new PANOLENS.Infospot(250, 'pano/Hotspot9.png');
  spot5toAdd2.position.set(4000, -100, 500);
  const spot5toUP = new PANOLENS.Infospot(250, 'pano/UP4.png');
  spot5toUP.position.set(2000, 4500, 4000);

  const spotAdd2to6 = new PANOLENS.Infospot(250, 'pano/Hotspot19.png');
  spotAdd2to6.position.set(450, -100, -3500);
  const spotAdd2to5 = new PANOLENS.Infospot(250, 'pano/Hotspot20.png');
  spotAdd2to5.position.set(700, 0, 4000);
  const spotAdd2toUP = new PANOLENS.Infospot(250, 'pano/Hotspot21.png');
  spotAdd2toUP.position.set(4500, 5000, -100);

  const spot6toAdd2 = new PANOLENS.Infospot(250, 'pano/Hotspot10.png');
  spot6toAdd2.position.set(-650, -100, 3500);
  const spot6to1 = new PANOLENS.Infospot(250, 'pano/Home.png');
  spot6to1.position.set(750, 0, -3000);
  const spot6toUP = new PANOLENS.Infospot(250, 'pano/UP5.png');
  spot6toUP.position.set(3500, 4500, 1500);

  const spotUPto1 = new PANOLENS.Infospot(250, 'pano/Hotspot11.png');
  spotUPto1.position.set(-1200, -5000, 500);
  const spotUPto2 = new PANOLENS.Infospot(250, 'pano/Hotspot12.png');
  spotUPto2.position.set(-350, -5000, -600);
  const spotUPto3 = new PANOLENS.Infospot(250, 'pano/Hotspot13.png');
  spotUPto3.position.set(-100, -5000, -1550);
  const spotUPto4 = new PANOLENS.Infospot(250, 'pano/Hotspot14.png');
  spotUPto4.position.set(-450, -5000, -2250);
  const spotUPto5 = new PANOLENS.Infospot(250, 'pano/Hotspot15.png');
  spotUPto5.position.set(3100, -5000, -1100);
  const spotUPto6 = new PANOLENS.Infospot(250, 'pano/Hotspot16.png');
  spotUPto6.position.set(1200, -5000, 2200);
  const spotUptoAdd = new PANOLENS.Infospot(250, 'pano/Hotspot22.png');
  spotUptoAdd.position.set(-1500, -5000, 2050);
  const spotUptoAdd2 = new PANOLENS.Infospot(250, 'pano/Hotspot23.png');
  spotUptoAdd2.position.set(2065, -5000, 1200);

  // Attach events (mirror your original mapping)
  spot1to2.addEventListener('click', () => switchPanorama(spot1to2, panoramas[1], spot2to1));
  spot1toUP.addEventListener('click', () => switchPanorama(spot1toUP, panoramas[6], spotUPto1));
  spot1toAdd.addEventListener('click', () => switchPanorama(spot1toAdd, panoramas[7], spotAddto1));

  spot2to1.addEventListener('click', () => switchPanorama(spot2to1, panoramas[0], spot1to2));
  spot2to3.addEventListener('click', () => switchPanorama(spot2to3, panoramas[2], spot3to2));
  spot2toUP.addEventListener('click', () => switchPanorama(spot2toUP, panoramas[6], spotUPto2));

  spot3to2.addEventListener('click', () => switchPanorama(spot3to2, panoramas[1], spot2to3));
  spot3to4.addEventListener('click', () => switchPanorama(spot3to4, panoramas[3], spot4to3));
  spot3toUP.addEventListener('click', () => switchPanorama(spot3toUP, panoramas[6], spotUPto3));

  spot4to3.addEventListener('click', () => switchPanorama(spot4to3, panoramas[2], spot3to4));
  spot4to5.addEventListener('click', () => switchPanorama(spot4to5, panoramas[4], spot5to4));
  spot4toUP.addEventListener('click', () => switchPanorama(spot4toUP, panoramas[6], spotUPto4));

  spot5to4.addEventListener('click', () => switchPanorama(spot5to4, panoramas[3], spot4to5));
  spot5toAdd2.addEventListener('click', () => switchPanorama(spot5toAdd2, panoramas[8], spotAdd2to5));
  spot5toUP.addEventListener('click', () => switchPanorama(spot5toUP, panoramas[6], spotUPto5));

  spot6toAdd2.addEventListener('click', () => switchPanorama(spot6toAdd2, panoramas[8], spotAdd2to6));
  spot6to1.addEventListener('click', () => switchPanorama(spot6to1, panoramas[7], spotAddto1));
  spot6toUP.addEventListener('click', () => switchPanorama(spot6toUP, panoramas[6], spotUPto6));

  spotUPto1.addEventListener('click', () => switchPanorama(spotUPto1, panoramas[0], spot1toUP));
  spotUPto2.addEventListener('click', () => switchPanorama(spotUPto2, panoramas[1], spot2toUP));
  spotUPto3.addEventListener('click', () => switchPanorama(spotUPto3, panoramas[2], spot3toUP));
  spotUPto4.addEventListener('click', () => switchPanorama(spotUPto4, panoramas[3], spot4toUP));
  spotUPto5.addEventListener('click', () => switchPanorama(spotUPto5, panoramas[4], spot5toUP));
  spotUPto6.addEventListener('click', () => switchPanorama(spotUPto6, panoramas[5], spot6toUP));
  spotUptoAdd.addEventListener('click', () => switchPanorama(spotUptoAdd, panoramas[7], spotAddtoUp));
  spotUptoAdd2.addEventListener('click', () => switchPanorama(spotUptoAdd2, panoramas[8], spotAdd2toUP));

  spotAddto1.addEventListener('click', () => switchPanorama(spotAddto1, panoramas[0], spot1toAdd));
  spotAddtoUp.addEventListener('click', () => switchPanorama(spotAddtoUp, panoramas[6], spotUptoAdd));

  spotAdd2to5.addEventListener('click', () => switchPanorama(spotAdd2to5, panoramas[4], spot5toAdd2));
  spotAdd2to6.addEventListener('click', () => switchPanorama(spotAdd2to6, panoramas[5], spot6toAdd2));
  spotAdd2toUP.addEventListener('click', () => switchPanorama(spotAdd2toUP, panoramas[6], spotUptoAdd2));

  // Add hotspots to panoramas
  panoramas[0].add(spot1toAdd, spot1to2, spot1toUP);
  panoramas[1].add(spot2to1, spot2to3, spot2toUP);
  panoramas[2].add(spot3to2, spot3to4, spot3toUP);
  panoramas[3].add(spot4to3, spot4to5, spot4toUP);
  panoramas[4].add(spot5to4, spot5toAdd2, spot5toUP);
  panoramas[5].add(spot6toAdd2, spot6to1, spot6toUP);
  panoramas[6].add(spotUPto1, spotUPto2, spotUPto3, spotUPto4, spotUPto5, spotUPto6, spotUptoAdd, spotUptoAdd2);
  panoramas[7].add(spotAddto1, spotAddtoUp);
  panoramas[8].add(spotAdd2to5, spotAdd2to6, spotAdd2toUP);
}

// transitions & switch (same logic as your pano code)
function switchPanorama(hotspot, targetPanorama, correspondingTargetHotspot) {
  try {
    panoViewer.tweenControlCenter(hotspot.position, 1000, TWEEN.Easing.Quadratic.InOut);
  } catch(e){}

  const startFov = panoCamera ? panoCamera.fov : 70;
  const zoomDuration = 1000;
  let startTime = null;

  function animateZoom(time) {
    if (!startTime) startTime = time;
    const elapsed = time - startTime;
    const progress = Math.min(elapsed / zoomDuration, 1);
    if (panoCamera) {
      panoCamera.fov = startFov + (30 - startFov) * progress;
      panoCamera.updateProjectionMatrix();
    }

    if (progress < 1) {
      requestAnimationFrame(animateZoom);
    } else {
      panoFade.style.opacity = 1;

      setTimeout(() => {
        try { panoViewer.setPanorama(targetPanorama); } catch (e) {}
        if (correspondingTargetHotspot && panoViewer) {
          try { panoViewer.tweenControlCenter(correspondingTargetHotspot.position, 0); } catch (e) {}
        }
        if (panoCamera) {
          panoCamera.fov = startFov;
          panoCamera.updateProjectionMatrix();
        }

        setTimeout(() => {
          panoFade.style.opacity = 0;
        }, 300);
      }, 500);
    }
  }

  requestAnimationFrame(animateZoom);
}

// open panorama overlay on click
document.getElementById('panoPreview').addEventListener('click', ()=>{
  // show overlay full screen
  panoOverlay.style.display = 'block';
  document.body.style.overflow = 'hidden';

  // create viewer only on first open (or recreate if it was destroyed)
  if (!panoInitialized) {
    // small delay to ensure overlay layout is applied before creating the viewer
    requestAnimationFrame(()=> {
      try {
        createPanoramaViewer();
      } catch (e) {
        console.error('Failed to init panorama viewer:', e);
      }
    });
  } else {
    // if already initialized, resize/update renderer if needed
    try {
      if (panoViewer && panoViewer.onWindowResize) panoViewer.onWindowResize();
    } catch(e){}
  }
});

// close panorama overlay and attempt to free memory
document.getElementById('closePanoOverlay').addEventListener('click', ()=>{
  panoOverlay.style.display = 'none';
  document.body.style.overflow = '';

  // try to dispose/destroy viewer & free memory (best-effort)
  try {
    if (panoViewer) {
      // remove panoramas from viewer
      try {
        panoViewer.remove(...panoramas);
      } catch(e){}

      // attempt to dispose renderer context if present
      try {
        if (panoViewer.renderer) {
          // force WebGL context loss to free GPU memory (best-effort)
          const gl = panoViewer.renderer.getContext && panoViewer.renderer.getContext();
          if (gl && gl.getExtension) {
            const loseExt = gl.getExtension('WEBGL_lose_context') || gl.getExtension('MOZ_WEBGL_lose_context') || gl.getExtension('WEBKIT_WEBGL_lose_context');
            if (loseExt) {
              loseExt.loseContext();
            }
          }
          // clear DOM
          if (panoViewer.renderer.domElement && panoViewer.renderer.domElement.parentNode) {
            panoViewer.renderer.domElement.parentNode.removeChild(panoViewer.renderer.domElement);
          }
        }
      } catch (e) {
        console.warn('Error while disposing renderer:', e);
      }

      // clear container inner HTML (remove any remaining canvases)
      panoContainer.innerHTML = '';

      // clear arrays and references
      panoramas.length = 0;
      panoramas = [];
      panoViewer = null;
      panoCamera = null;
      panoLoader = null;
      panoInitialized = false;

      // clear THREE caches if available
      try { THREE.Cache && THREE.Cache.clear && THREE.Cache.clear(); } catch(e){}
    }
  } catch (e) {
    console.warn('Error while destroying panorama viewer:', e);
  }
});
</script>

</body>
</html>
